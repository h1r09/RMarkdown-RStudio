---
title: "Indicadores"
author: "Hunor Moriczi"
date: '2022-05-08'
output:
  pdf_document: default
  html_document: default
---

## Ejemplo de funcion en RMarkdown

Crea una variable llamada ejemplo con la cadena "variable de ejemplo" y la muestra.

```{r Funcion_ejemplo}
ejemplo <- "variable de ejemplo"
View(ejemplo)
```

Otros comandos interesantes:

-   Borra todos los objetos en la sesión de R rm(list = ls())

-   Comprueba si todavía hay algún objeto en la sesión ls()

## Carga de datos

Para empezar a trabajar se va a relaizar la carga de datos de los archivos .csv, obtenidos en el análisis de SonarQueb mediante SourceMeter.

Al tratarse de archivos .csv se pueden cargar empleando las siguientes funciones:

Primero obtengo las rutas de los archivos mediante la funcion file.choose(), que abrirá un explorador del sistema y me dará las rutas de los archivos seleccionados.

Estas rutas las guardaré en variables para poder hacer uso de ella más adelante.

```{r Obtener_ruta}
file.choose()
```

obtengo todas las rutas de los 3 archivos obtenidos, class y method, de las 3 versiones analizadas:

```{r rutas_excel}
ruta_ClassV1 <- "datos\\sonarqube-8.9.7.52159\\SonarQube_Hunor-Class-V1.csv"
ruta_ClassV2 <- "datos\\sonarqube-9.2.4.50792\\SonarQube_Hunor-Class-V2.csv"
ruta_ClassV3 <- "datos\\sonarqube-9.3.0.51899\\SonarQube_Hunor-Class-V3.csv"

ruta_MethodV1 <- "datos\\sonarqube-8.9.7.52159\\SonarQube_Hunor-Method-V1.csv"
ruta_MethodV2 <- "datos\\sonarqube-9.2.4.50792\\SonarQube_Hunor-Method-V2.csv"
ruta_MethodV3 <- "datos\\sonarqube-9.3.0.51899\\SonarQube_Hunor-Method-V3.csv"

```

Ahora mediante la librería readr, guardo los datos de los excel en variables.

```{r carga_a_variables}
library(readr)
datasetClassV1 <- read_csv(ruta_ClassV1)
datasetClassV2 <- read_csv(ruta_ClassV2)
datasetClassV3 <- read_csv(ruta_ClassV3)

datasetMethodV1 <- read_csv(ruta_MethodV1)
datasetMethodV2 <- read_csv(ruta_MethodV2)
datasetMethodV3 <- read_csv(ruta_MethodV3)

```

Una vez cargados los datos veo la información que me da cada archivo o la información que es relevante para mi.

### Archivos Class

-   Una metrica interesante es la columna CBO, que el CBO de una clase es el número de clases a las cuales una clase está ligada. Se da dependencia entre dos clases cuando una clase usa métodos o variables de la otra clase. Las clases relacionadas por herencia no se tienen en cuenta.Se propone como indicador del esfuerzo necesario para el mantenimiento y en el testeo. Cuanto más acoplamiento se da en una clase, más dificil será reutilizarla.

-   Otra que tomaré en cuenta es la columna RFC, que es el cardinal del conjunto de todos los métodos que pueden ser invocados en respuesta a un mensaje a un objeto de la clase o por alguno método en la clase. Esto incluye todos los métodos accesibles dentro de la jerarquía de la clase. En otras palabras, cuenta las ocurrencias de llamadas a otras clases desde una clase particular.

-   Otra medida que se puede tener en cuenta es la columna LCOM, que es es una medida de la cohesión de una clase midiendo el número de atributos comunes usados por diferentes métodos, indicando la calidad de la abstracción hecha en la clase. Un valor alto de LCOM implica falta de cohesión, es decir, escasa similitud de los métodos. Esto puede indicar que la clase está compuesta de elementos no relacionados, incrementando la complejidad y la probabilidad de errores durante el desarrollo.

-   Otra medida que se puede emplear es la columna WMC. Que mide la complejidad de una clase.Sugieren un umbral de 40 o 20, dependiendo si las clases son o no de interface de usuario respectivamente.

### Archivos Method

-   Una metrica para los metodos podría ser NOS, numero de pasoso número de sentencias y LOC lineas de código. Otra cosa a tener en cuenta es la columna TLLOC que es "Total Logical Lines of Code"

```{r elegir_columna}
LOC_classV1 <- datasetClassV1$LOC
LOC_classV2 <- datasetClassV2$LOC
LOC_classV3 <- datasetClassV3$LOC

CBO_classV1 <- datasetClassV1$CBO
CBO_classV2 <- datasetClassV2$CBO
CBO_classV3 <- datasetClassV3$CBO

WMC_classV1 <- datasetClassV1$WMC
WMC_classV2 <- datasetClassV2$WMC
WMC_classV3 <- datasetClassV3$WMC

LCOM5_classV1 <- datasetClassV1$LCOM5
LCOM5_classV2 <- datasetClassV2$LCOM5
LCOM5_classV3 <- datasetClassV3$LCOM5


LOC_methodV1 <- datasetMethodV1$LOC
LOC_methodV2 <- datasetMethodV2$LOC
LOC_methodV3 <- datasetMethodV3$LOC

NOS_methodV1 <- datasetMethodV1$NOS
NOS_methodV2 <- datasetMethodV2$NOS
NOS_methodV3 <- datasetMethodV3$NOS
```

```{r ver_LOC}
View(LOC_classV1)

```

```{r tabla_Frecuencia_NOS}
freqNOS_classV1 <- table(cut(NOS_methodV1, breaks = c(0,1,5,10,15,20,25,50,100,200,300,400), right = F, include.lowest = T), exclude = NULL)

rownames(freqNOS_classV1) <- c('0-1','1-5','5-10','10-15','15-20','20-25','25-50','50-100','100-200','200-300','300-400')


barplot(freqNOS_classV1)
```

### En este bloque se obtienen los minimos y maximos de cada vetor de datos, para poder realizar unas tablas de frecuencia con sentido.

-   Cálculo de min y max LOC clases

```{r min_max_LOC}
min_LOC_ClassV1 <- min(datasetClassV1$LOC)
min_LOC_ClassV2 <- min(datasetClassV2$LOC)
min_LOC_ClassV3 <- min(datasetClassV3$LOC)
max_LOC_ClassV1 <- max(datasetClassV1$LOC)
max_LOC_ClassV2 <- max(datasetClassV2$LOC)
max_LOC_ClassV3 <- max(datasetClassV3$LOC)

```

-   Cálculo de min y max CBO clases

```{r min_max_CBO}
min_CBO_ClassV1 <- min(datasetClassV1$CBO)
min_CBO_ClassV2 <- min(datasetClassV2$CBO)
min_CBO_ClassV3 <- min(datasetClassV3$CBO)
max_CBO_ClassV1 <- max(datasetClassV1$CBO)
max_CBO_ClassV2 <- max(datasetClassV2$CBO)
max_CBO_ClassV3 <- max(datasetClassV3$CBO)

```

-   Cálculo de min y max LCOM5 clases

```{r min_max_LCOM5}
min_LCOM5_ClassV1 <- min(datasetClassV1$LCOM5)
min_LCOM5_ClassV2 <- min(datasetClassV2$LCOM5)
min_LCOM5_ClassV3 <- min(datasetClassV3$LCOM5)
max_LCOM5_ClassV1 <- max(datasetClassV1$LCOM5)
max_LCOM5_ClassV2 <- max(datasetClassV2$LCOM5)
max_LCOM5_ClassV3 <- max(datasetClassV3$LCOM5)

```

-   Cálculo de min y max WMC clases

```{r min_max_WCM}
min_WMC_ClassV1 <- min(datasetClassV1$WMC)
min_WMC_ClassV2 <- min(datasetClassV2$WMC)
min_WMC_ClassV3 <- min(datasetClassV3$WMC)
max_WMC_ClassV1 <- max(datasetClassV1$WMC)
max_WMC_ClassV2 <- max(datasetClassV2$WMC)
max_WMC_ClassV3 <- max(datasetClassV3$WMC)

```

```{r tabla_Frecuencia_LOC}
freqLOC_classV1 <- table(cut(LOC_classV1, breaks = c(0,25,50,100,250,500,1000,2000), right = F, include.lowest = T), exclude = NULL)
freqLOC_classV2 <- table(cut(LOC_classV2, breaks = c(0,25,50,100,250,500,1000,2000), right = F, include.lowest = T), exclude = NULL)
freqLOC_classV3 <- table(cut(LOC_classV3, breaks = c(0,25,50,100,250,500,1000,2000), right = F, include.lowest = T), exclude = NULL)

rownames(freqLOC_classV1) <- c('0-25','25-50','50-100','100-250','250-500','500-1000','1000-2000')

barplot(freqLOC_classV1,
        main = 'Líneas de Código V1',
        col = 'lightblue',
        xlab = 'Líneas de código',
        ylab = 'Cantidad')
barplot(freqLOC_classV2,
        main = 'Líneas de Código V2',
        col = 'blue',
        xlab = 'Líneas de código',
        ylab = 'Cantidad')
barplot(freqLOC_classV3,
        main = 'Líneas de Código V3',
        col = 'red',
        xlab = 'Líneas de código',
        ylab = 'Cantidad')
```

```{r tabla_Frecuencia_CBO}
freqCBO_classV1 <- table(cut(CBO_classV1, breaks = c(0,1,5,10,15,20,25,50,100,200,300,321), right = F, include.lowest = T), exclude = NULL)

rownames(freqCBO_classV1) <- c('0-1','1-5','5-10','10-15','15-20','20-25','25-50','50-100','100-200','200-300','300-321')

barplot(freqCBO_classV1)
```

Mediante un histograma se puede sacar la misma informacion, pero para ver mejor la dispersion es mejor emplear barplot y establecer otros rangos.
```{r Histograma}
hist(datasetClassV1$LCOM5)
```

```{r tabla_Frecuencia_LCOM5}
freqLCOM5_classV1 <- table(cut(LCOM5_classV1, breaks = c(0,1,2,3,4,5,10,15,20,25,30,35,40,45,55), right = F, include.lowest = T), exclude = NULL)
freqLCOM5_classV2 <- table(cut(LCOM5_classV2, breaks = c(0,1,2,3,4,5,10,15,20,25,30,35,40,45,55), right = F, include.lowest = T), exclude = NULL)
rownames(freqLCOM5_classV1) <- c('0-1','1-2','2-3','3-4','4-5','5-10','10-15','15-20','20-25','25-30','30-35','35-40','40-45','45-55')

barplot(freqLCOM5_classV1,
        col = 'blue',
        xlab = 'LCOM5',
        ylab = 'Cantidad',
        )
barplot(freqLCOM5_classV2,
        col = 'red',
        xlab = 'LCOM5',
        ylab = 'Cantidad')

```



```{r tabla_Frecuencia_WMC}
freqWMC_classV1 <- table(cut(WMC_classV1, breaks = c(0,2,4,6,8,10,20,30,40,50,60,70,80,90,100,110,123), right = F, include.lowest = T), exclude = NULL)

rownames(freqWMC_classV1) <- c('0-2','2-4','4-6','6-8','8-10','10-20','20-30','30-40','40-50','50-60','60-70','70-80','80-90','90-100','100-110','110-123')

barplot(freqWMC_classV1)
```

### Medias de las metricas que emplearé

Medias de todas las columnas que voy a emplear para analizar el código: CBO, LOC, LCOM5 y WMC para las me´tricas de clases.
- LOC --> La media de las líneas de código de cada version analizada.
- CBO --> La media del CBO de cada verion analizada. Se propone como indicador del esfuerzo necesario para el mantenimiento y en el testeo. Cuanto más acoplamiento, mayor CBO,  se da en una clase, más dificil será reutilizarla.
- LCOM5 --> La media del LCOM5. Se puede crear un indicador ya que un valor alto de LCOM implica falta de cohesión, es decir, escasa similitud de los métodos.
- WMC --> LA media del WMC de las versiones analizadas. Mide la complejidad de una clase. Sugieren un umbral de 40 o 20, dependiendo si las clases son o no de interface de usuario respectivamente. UN valor alto indicaría un esfuerzo grande para desarollar, mantener y testear la clase. Se debe mantener un valor MWC lo más bajo posible.

```{r Medias}
mediaLOC_ClassV1 <- mean(LOC_classV1)
mediaLOC_ClassV2 <- mean(LOC_classV2)
mediaLOC_ClassV3 <- mean(LOC_classV3)

mediaCBO_ClassV1 <- mean(CBO_classV1)
mediaCBO_ClassV2 <- mean(CBO_classV2)
mediaCBO_ClassV3 <- mean(CBO_classV3)

mediaLCOM5_ClassV1 <- mean(LCOM5_classV1)
mediaLCOM5_ClassV2 <- mean(LCOM5_classV2)
mediaLCOM5_ClassV3 <- mean(LCOM5_classV3)

mediaWMC_ClassV1 <- mean(WMC_classV1)
mediaWMC_ClassV2 <- mean(WMC_classV2)
mediaWMC_ClassV3 <- mean(WMC_classV3)

mediaMethodV1 <- mean(LOC_methodV1)
mediaMethodV2 <- mean(LOC_methodV2)
mediaMethodV3 <- mean(LOC_methodV3)

```

```{r indicador_CBO}
mediaCBO_30 <- (mediaCBO_ClassV1 * 0.3) + mediaCBO_ClassV1
Clases_aRevisar_CBO_Alto <- datasetClassV1 [datasetClassV1$CBO > mediaCBO_30 ,]
```

```{r ver_LOC}
View(Clases_aRevisar_CBO_Alto)
Clases_aRevisar_CBO_Alto
```

Moda para pero el número que más se repite dentro de los datos.

```{r ver_LOC}
Moda <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}
modaClassV1 <- Moda(LOC_classV1)
modaClassV2 <- Moda(LOC_classV2)
modaClassV3 <- Moda(LOC_classV3)
```

Las medidas de dispersion nos dicen que tan parecidos o diferentes pueden llegar a ser nuestrpos dataset

```{r medidas_dispersion}
medidasV1 <- max(datasetClassV1$LOC) - min(datasetClassV1$LOC)
View(medidasV1)
```

Densidad de lineas de codigo por clase

```{r densidad_classV1}
plot(density(datasetClassV1$CBO), main="Densidad de líneas de código")
```

```{r densidad_classV1}
plot(density(datasetMethodV1$NOS), main="Densidad NOS Method V1")
```

```{r grafico_pie}
pie(table(datasetClassV1$LOC))
```

```{r Boxplot}
boxplot(x=datasetClassV1[,41:42],main="Boxplots LOC")
```
